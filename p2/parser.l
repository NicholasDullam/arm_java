%{
// Includes the definition of symbolic tokens. The enum definition in this
// header file replaces the `enum Token {...}` you wrote in project 1.
// It also includes the declaration of the global variable `yylval` which will
// be used by code generated by Yacc/Bison.
//
// This header file is generated by Yacc/Bison from parser.y. We suggest that
// you take a look at the content of this header file - it's not long.
#include "y.tab.h"

#include <stdio.h>
#include <stdlib.h>
extern int yylex();
%}

%option yylineno

%%
"//".*                               { } /* inline comments */
"/*"([^\*]|("*"+[^\/\*]))*"*"+"/"    { } /* block comments  */
[ \t\n]                              { } /* skip whitespace */

if                    { return KW_IF;                 } /* keywords */
else                  { return KW_ELSE;               }
new                   { return KW_NEW;                }
boolean               { return KW_BOOLEAN;            }
class                 { return KW_CLASS;              }
false                 { return KW_FALSE;              }
int                   { return KW_INT;                }
main                  { return MAIN;                  }
public                { return KW_PUBLIC;             }
private               { return KW_PRIVATE;            }
static                { return KW_STATIC;             }
String                { return KW_STRING;             }
System\.out\.print    { return SYSTEM_OUT_PRINT;      }
System\.out\.println  { return SYSTEM_OUT_PRINTLN;    }
Integer\.ParseInt     { return INTEGER_PARSE_INT;     }
void                  { return KW_VOID;               }

"&&"                  { return TOK_AND;               } /* operators */
"||"                  { return TOK_OR;                }
"<"                   { return TOK_LESS;              }
">"                   { return TOK_GREAT;             }   
"<="                  { return TOK_LEQ;               }
">="                  { return TOK_GREQ;              }
"!="                  { return TOK_NEQ;               }
"=="                  { return TOK_EQ;                }
"+"                   { return TOK_PLUS;              }
"-"                   { return TOK_MINUS;             }
"*"                   { return TOK_MULT;              }
"/"                   { return TOK_DIV;               }
"!"                   { return TOK_NOT;               }

\{                    { return *yytext;               } /* other */
\}                    { return *yytext;               }
\[                    { return *yytext;               }
\]                    { return *yytext;               }
\(                    { return *yytext;               }
\)                    { return *yytext;               } 
\=                    { return *yytext;               }
\;                    { return *yytext;               }
\,                    { return *yytext;               }


[0-9]+ {
    yylval.integer = atoi(strdup(yytext));
    return INTEGER_LITERAL;
}

[a-zA-Z][a-zA-Z0-9_]* {
    yylval.string = strdup(yytext);
    return ID;                 
}

\"([^"\\]|\\.)*\" {
    yylval.string = strdup(yytext);
    return STRING_LITERAL;                    
}

%%

int yywrap(void) {
    return 1;
}