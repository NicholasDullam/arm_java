# Project 3 Overview

## Memory allocation and offsets
When it comes to variable assignments and memory allocation, I generally follow through the order of static variables (outside of the stack, in the ```.data``` section), followed by arguments (with a small caveat with ```main```), then local variable assignments, and finally temporary assignments. Offsets are applied to each of these variables in the order with which they're addressed; however, not all temporary assignments gain offsets, as is the case with leaf nodes like literals and left-value references which don't require stack allocation. As aforementioned, when it comes to argument assignments, there is a small caveat with the main method that revolves around the variable length of its command line entries. By default, these arguments are not directly assigned offsets, but rather exist at the perpetual end of the stack. For example, ```argc``` will be allocated at the max offset of all local variable, and temporary variable declarations, plus 4, with ```argv``` allocated at the max offset plus 8; and any argument references follow this design pattern for the offset. In the final run through, these standard and adjusted offsets are added and subtracted from the stack reference.

## High Level Generation
My generation procedure first follows through with the generation of the 3AC psuedo instructions, followed by the reevaluation of the instruction tree for the generation of ARM assembly instructions. When generating the 3AC instructions, as I navigate the AST I generate instruction scopes that follow the design paradigm outlined in the lectures to an extent -- allowing for ease of reference to child arguments, in the case of expressions, and full control of the coalesced instructions before writing to the file. For example, when creating a method, I would create a new ```InstructionEntry``` that can hold all relevant instructions for the given node or nodes. However, all instructions written at the node will appear at the end of the method and its children when it is coalesced. So to combat that, I can simply create a new ```InstructionEntry```, serving as a pseudo scope structure, where I can pass configuration information for the method to appear at the beginning, like the branch name. Now, when post-processing this structure at the time of generating the ARM assembly instructions, I re-evaluated the scope, node, and instruction entry characteristics to generate the instructions -- changing them in-place.